<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vercel JSON File Manager</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding-right: 450px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      padding: 10px;
      border: 1px solid #ddd;
      text-align: left;
    }
    th {
      background-color: #f4f4f4;
    }
    .filter-section, .action-section {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .filter-section {      
      flex-wrap: wrap;
    }
    .datetime-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .datetime-group label {
      white-space: nowrap;
    }
    input, button {
      padding: 8px;
    }
    .file-content {
      white-space: pre-wrap;
      background-color: #f9f9f9;
      padding: 10px;
      border: 1px solid #ddd;
      max-height: 300px;
      overflow-y: auto;
      position: fixed;
      top: 20px;
      right: 20px;
      width: 400px;
      z-index: 1000;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .filename {
      cursor: pointer;
      color: #0066cc;
    }
    .filename:hover {
      text-decoration: underline;
    }
    .info-section {
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 5px;
    }
    .selected-row {
      background-color: #e6f3ff; /* 淡蓝色 */
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Vercel JSON File Manager</h1>

    <!-- Info section -->
    <div class="info-section" id="infoSection">
      Selected file information will appear here
    </div>

    <!-- Filter section -->
    <div class="filter-section">
      <input type="text" id="filterInput" placeholder="Enter date (YYYYMMDD) or filename keyword" />
      <div class="datetime-group">
        <label>Start Time:</label>
        <input type="datetime-local" id="startDateTime" step="1">
      </div>
      <div class="datetime-group">
        <label>End Time:</label>
        <input type="datetime-local" id="endDateTime" step="1">
      </div>
      <button onclick="filterFiles()">Filter</button>
      <button onclick="resetFilter()">Reset</button>
    </div>

    <!-- Action section -->
    <div class="action-section">
      <button onclick="downloadSelected()">Download Selected</button>
      <button onclick="exportToExcel()">Export Selected to Excel</button>
    </div>

    <!-- File list -->
    <table id="fileTable">
      <thead>
        <tr>
          <th><input type="checkbox" id="selectAll" onchange="toggleSelectAll()"></th>
          <th>Filename</th>
          <th>Size (bytes)</th>
          <th>Upload Time</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="fileList"></tbody>
    </table>

    <!-- File content display area -->
    <div id="fileContent" class="file-content"></div>
  </div>

  <script>
    let allFiles = [];
    let currentSelectedFile = null;

    // Initialize
    window.onload = async () => {
      await fetchFiles();
      renderFileList(allFiles);
      document.getElementById('startDateTime').title = 'Format: YYYY-MM-DD HH:MM:SS';
      document.getElementById('endDateTime').title = 'Format: YYYY-MM-DD HH:MM:SS (empty for current time)';
    };

    // Fetch file list
    async function fetchFiles() {
      try {
        const response = await fetch('/api/logviewer?method=LIST');
        const result = await response.json();
        if (result.success) {
          allFiles = result.files;
        } else {
          alert('Failed to fetch file list: ' + result.message);
        }
      } catch (error) {
        console.error('Error fetching files:', error);
        alert('Failed to fetch file list');
      }
    }

    // Render file list
    function renderFileList(files) {
      const tbody = document.getElementById('fileList');
      tbody.innerHTML = '';
      files.forEach(file => {
        const tr = document.createElement('tr');
        tr.dataset.filename = file.fileName;
        tr.innerHTML = `
          <td><input type="checkbox" class="file-checkbox" data-filename="${file.fileName}"></td>
          <td><span class="filename" onclick="viewFile('${file.url}', this)">${file.fileName}</span></td>
          <td>${file.size}</td>
          <td>${new Date(file.uploadedAt).toLocaleString()}</td>
          <td>
            <button onclick="downloadFile('${file.url}', '${file.fileName}')">Download</button>
          </td>
        `;
        tbody.appendChild(tr);
      });
    }

    function formatDateTime(date) {
      if (!date) return '';
      const d = new Date(date);
      return `${d.getFullYear()}-${padZero(d.getMonth() + 1)}-${padZero(d.getDate())} ${padZero(d.getHours())}:${padZero(d.getMinutes())}:${padZero(d.getSeconds())}`;
    }

    function padZero(num) {
      return num < 10 ? `0${num}` : num;
    }

    // Filter files
    function filterFiles() {
      const filterValue = document.getElementById('filterInput').value.toLowerCase();
      const startDateTime = document.getElementById('startDateTime').value;
      let endDateTime = document.getElementById('endDateTime').value;

      let filteredFiles = allFiles;

      if (filterValue) {
        filteredFiles = filteredFiles.filter(file => 
          file.fileName.toLowerCase().includes(filterValue)
        );
      }

      if (startDateTime || endDateTime) {
        filteredFiles = filteredFiles.filter(file => {
          const fileDate = new Date(file.uploadedAt);
          const start = startDateTime ? new Date(startDateTime) : null;
          const end = endDateTime ? new Date(endDateTime) : new Date();

          if (start && !endDateTime) {
            return fileDate >= start && fileDate <= new Date();
          }
          if (!startDateTime && end) {
            return fileDate <= end;
          }
          if (start && end) {
            return fileDate >= start && fileDate <= end;
          }
          return true;
        });
      }

      if (startDateTime) {
        document.getElementById('startDateTime').title = formatDateTime(startDateTime);
      }
      if (endDateTime) {
        document.getElementById('endDateTime').title = formatDateTime(endDateTime);
      } else {
        document.getElementById('endDateTime').title = formatDateTime(new Date());
      }

      renderFileList(filteredFiles);
    }

    // Reset filter
    function resetFilter() {
      document.getElementById('filterInput').value = '';
      document.getElementById('startDateTime').value = '';
      document.getElementById('startDateTime').title = '';
      document.getElementById('endDateTime').value = '';
      document.getElementById('endDateTime').title = '';
      document.getElementById('infoSection').textContent = 'Selected file information will appear here';
      renderFileList(allFiles);
    }

    // Toggle select all
    function toggleSelectAll() {
      const selectAll = document.getElementById('selectAll').checked;
      document.querySelectorAll('.file-checkbox').forEach(checkbox => {
        checkbox.checked = selectAll;
      });
    }

    // View file content
    async function viewFile(fileUrl, element) {
      try {
        const response = await fetch(fileUrl);
        const result = await response.json();
        const contentDiv = document.getElementById('fileContent');
        contentDiv.textContent = JSON.stringify(result, null, 2);

        // Remove previous selection
        if (currentSelectedFile) {
          currentSelectedFile.closest('tr').classList.remove('selected-row');
        }
        
        // Add new selection
        const row = element.closest('tr');
        row.classList.add('selected-row');
        currentSelectedFile = element;

        // Update info section
        const fileName = row.dataset.filename;
        const file = allFiles.find(f => f.fileName === fileName);
        document.getElementById('infoSection').textContent = 
          `Selected File: ${file.fileName}\nSize: ${file.size} bytes\nUploaded: ${new Date(file.uploadedAt).toLocaleString()}`;

      } catch (error) {
        console.error('Error viewing file:', error);
        const contentDiv = document.getElementById('fileContent');
        contentDiv.textContent = 'Failed to load file content: ' + error.message;
      }
    }

    // Download single file
    function downloadFile(url, fileName) {
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    // Get selected files
    function getSelectedFiles() {
      const checkboxes = document.querySelectorAll('.file-checkbox:checked');
      return Array.from(checkboxes).map(cb => cb.dataset.filename);
    }

    // Download selected files
    function downloadSelected() {
      const selectedFiles = getSelectedFiles();
      if (selectedFiles.length === 0) {
        alert('Please select files first');
        return;
      }
      selectedFiles.forEach(fileName => {
        const file = allFiles.find(f => f.fileName === fileName);
        if (file) downloadFile(file.url, file.fileName);
      });
    }

    // Export to Excel
    async function exportToExcel() {
      const selectedFiles = getSelectedFiles();
      if (selectedFiles.length === 0) {
        alert('Please select files first');
        return;
      }

      const data = [];
      
      for (const fileName of selectedFiles) {
        const file = allFiles.find(f => f.fileName === fileName);
        if (file) {
          try {
            const response = await fetch(file.url);
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            const jsonData = await response.json();

            if (Array.isArray(jsonData)) {
              jsonData.forEach(item => {
                const formattedData = formatData(item, fileName);
                data.push(formattedData);
              });
            } else {
              const formattedData = formatData(jsonData, fileName);
              data.push(formattedData);
            }
          } catch (error) {
            console.error(`Error fetching file ${fileName}:`, error);
          }
        }
      }

      if (data.length === 0) {
        alert('No data to export');
        return;
      }

      const ws = XLSX.utils.json_to_sheet(data, {
        header: [
          "timestamp",
          "lineNumber",
          "palletLabel",
          "productName",
          "palletNumber",
          "boxCount",
          "hcode",
          "ubd",
          "topLabel",
          "sideLabel",
          "bottomLabel",
          "boxLabel",
          "waterMark",
          "filename"
        ]
      });
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Files");
      XLSX.writeFile(wb, `exported_files_${new Date().toISOString().slice(0,10)}.xlsx`);
    }

    // Format data for export
    function formatData(jsonData, fileName) {
      const data = jsonData.data || jsonData;
      const barcodes = data.barcodes || [];

      return {
        timestamp: data.timestamp || "",
        lineNumber: data.lineNumber || "",
        palletLabel: barcodes[4] || "",
        productName: data.productName || "",
        palletNumber: data.palletNumber || "",
        boxCount: data.boxCount || "",
        hcode: data.hcode || "",
        ubd: data.ubd || "",
        topLabel: barcodes[0] || "",
        sideLabel: barcodes[1] || "",
        bottomLabel: barcodes[2] || "",
        boxLabel: barcodes[3] || "",
        waterMark: barcodes[5] || "",
        filename: fileName
      };
    }
  </script>
</body>
</html>